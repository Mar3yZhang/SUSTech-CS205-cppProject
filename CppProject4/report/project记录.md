1.在实现类支持多种不同的数据类型时，尝试了void*，不好操作，只能定义区分开的5个类，很不优雅。

​	只能放弃在使用该矩阵类时能同时存在多种不同类型矩阵的功能，在使用类前先提前定好矩阵的类型，通过模板来选择矩阵的类型。<键入的数据类型>

​	再次使用void * 来实现 失败

​	尝试使用模板函数来实现 失败

​	尝试使用模板类 成功



模仿了CV::MAT来实现具有多种不同类型矩阵的

注：模板类成员函数的定义问题：函数实现不能定义在源文件中，一定要在头文件中。原本是想把函数实现和函数声明放在另外一个源文件当中的，但是使用模板类会提示不允许使用不完整的类型，要重复声明模板，为了减少代码量，直接把所有的成员函数定义都写在类中

​		经过修改，函数添加了template <class T>前缀后，可以在模板类完进行成员函数的定义，现在实现了头文件只用来存放函数声明，美观优雅。

1. void Matrix<class T>::**clear**()函数的实现存在缺点：

   析构函数在对象消亡时即自动被调用，对象消亡指的是离开了作用域或者没有指针再指向这片内存空间。
   
2. 这里重载运算符的=区分于copy方法，copy是clone，=是赋值

   注：在=的重载过程中可能存在存在内存泄露的问题，做条件判断避免内存泄漏。如果原来成员指针和等号右边的对象的指针指向的是同一块内存，应该避免释放掉这块内存。否则要释放等号左边对象的内存从而避免内存泄漏的问题。 因为是成员变量离开作用域而不是对象离开作用域，这里不会对象自动调用析构函数，只能手动释放内存，才能防止内存泄露。

ROI实现参考博客：https://waltpeter.github.io/open-cv-basic/region-of-interest/index.html

3. 参考OpenCV的Range类来实现感兴趣部分（ROI）查阅资料后了解到cv::mat的ROI实现有两种方法，1.利用矩形框Rect(x,y,width,height) 2. 确定感兴趣行列范围Range(start,end)， 这里我们选用第二种方法

   https://docs.opencv.org/4.x/da/d35/classcv_1_1Range.html

4. 生成真随机数： 使用cstdlib的rand()生成的随机数是通过线性同余法实现的具有周期性的假随机数，而根据时间来生成随机数种子可以生成不具有周期性的真随机数。

5. 关于浅拷贝和深拷贝： **浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

6. 在函数构造的过程中，cv::mat选择传入左闭右开的上下界作为参数，这里我选择传入起始行终止行，起始列终止列来作为参数，函数返回一个矩阵头。

   暂时没想到方法使得在不新的申请动态内存的前提下，使得ROI函数返回一个指向目标区域的指针，并且目标区域就是原区域的一个部分。

   在不新建任何辅助类的前提下，如果数据是离散的，怎么通过一维数组来表示呢？例如{1,2,3,4,5,6,7,8,9,10,11,12} 矩阵执行ROI(2,3,3,4) , 返回{7,8,11,12}，但7,8,11,12是四个不连续的数组成员。

   添加一个成员变量step来记录数据到边界之后的间隔，用于判断矩阵是否为某个已经存在矩阵的子矩阵，这里简称为ROI矩阵。

   若不为ROI矩阵，则step应该为1；否则，step应该是不连续元素的间隔(>1)。

   

7. 在测试代码时，我发现自己的编译器一直报连接错误，但是我的头文件编写和引入都是没有问题的，经过查阅资料，我发现模板类和声明和实现都写在头文件才能通过。

   因为模板类需要在使用到的地方利用声明模板的typename或者class参数的时候，才会即时生成代码。那么当我把模板声明和实现分开的时候，这个即时过程因为编译器只能通过代码include“看到”头文件而找不到模板实现代码，所以会产生链接问题。这也是为什么几乎都会建议模板类和声明和实现都写在头文件。
   https://blog.csdn.net/Cold_Sun_/article/details/100584418
   
8. ##### 没有严格计算指定内存的调用次数将会导致内存泄漏或者内存重复释放的错误，使得程序崩溃

   解决方法 ： 使用Smart_ptr (简单，自动)

   ​					使用计数来决定是否释放内存（麻烦）

   ![重复释放](project%E8%AE%B0%E5%BD%95.assets/%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE.PNG)

  //cd共享一块内存，析构函数被调用时，会造成内存重复释放的错误

//这里应该会调用默认的拷贝函数,

 //这里调用了拷贝构造函数

![重复释放2](project%E8%AE%B0%E5%BD%95.assets/%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE2.PNG)





9. 设计存在缺陷，如果用户操作失误，对两个不同类型的举矩阵计算操作，可能会出现很严重的问题。



c++ struct有静态c成员C++ 中引入 struct 是为了兼容 C，C++ 对结构体进行了一些扩充 C++ 中 struct 可以有成员函数 (构造函数、析构函数、常规函数和虚函数)、静态成员



不希望函数在过程中修改形式参数的引用，添加const



尝试使用shared_ptr来防止重复释放内存。



10.  **先实现没有考虑the number of channels的版本， 保证ROI和基本功能是能够实现的**

原本类成员的设计：

1.  long long row ，long long column，T * data,  shared_ptr mark ,  long long step ， int channel.

改变了设计思路：  shared_ptr 在使用的时候与普通指针存在冲突，很难做到用shared_ptr对一个指向这片空间的普通指针统计的访问次数，在ROI实现上存在问题。 根据思考后， 我发现根据数学知识，我们应该能够根据指向始祖矩阵的矩阵头的指针，行列step来确定新矩阵头的具体位置，所以我们不需要 T * data指针。 （只要指针的转化不会导致计数改变则逻辑上不存在错误，不需要再修改）

在普通的非初始化过程中，只需要把shared_ptr当成普通指针对待

![计数证明](project%E8%AE%B0%E5%BD%95.assets/%E8%AE%A1%E6%95%B0%E8%AF%81%E6%98%8E-16376599817981.PNG)

事实证明：将shared_ptr转化为普通指针时，shared_ptr的使用次数只收到指向同一块内存的shared_ptr的影响，并不受指向同一块内存的普通指针的影响。我们可以利用这个特性来实现在使用矩阵的ROI的同时避免内存的重复释放的问题。



在没有设计ROI的前提下实现了基本的内存管理

现在实现ROI

以现在的设计思路，只存储step = row是没法表示只由若干列形成的矩阵的，还必须要记录原矩阵的row 和 col

只由在 ROI 操作当中 exRow 和 exCol的值才会发生改变。 

如果行列与始祖行列不是一一对应关系，矩阵头大概率不在原处，需要添加一个指针成员在ROI时存储好矩阵头



如何按照循环的顺序访问在内存中离散的数据？找到一个恰当的散列函数是关键



进入循环体前，先把指针赋值给另一个临时指针。在循环当中，i从0开始， 当i + 1 % 3 = 0 时，指针到达（子）矩阵的边界，要跳过一段数据。在一维数组表示的矩阵当中等效跳过若干个数据。 跳跃值应该为 （Step - col）。即访问数据后 立刻执行 temp += （step - col）



设计 T &**Mat**(long long row , long long col) ///成员访问函数，访问第row行 ， 第 col 列 的元素

弊端，虽然通过一维数组来存储了数据，但是通过成员访问函数来访问数据会使得计算所需的时间上升，存在优化方法

解决方法：区分祖先矩阵和非祖先矩阵 ， 祖先矩阵和祖先矩阵的计算通过直接访问数据来计算。 非祖先矩阵和任何其他类型矩阵通过成员访问函数来计算	



通过一个bool来记录当前矩阵是否是祖先矩阵（**ancestor matrix**）



部分3要解释一下为什么使用smart_ptr



**遇到的问题，直接访问内存会出现随机值**，解决方法，对所有分配的内存先默认置零，等一下做一个记录	



记录：



从这里我改用 `Windows Terminal`进行操作，`Windows Terminal`因为允许光标在终端上进行复制操作，操作方便一些。

先安装`xshell`，使得文件传输支持图形化界面，否则下面键入rz指令的时候终端会死掉。

1. 使用 `yum provides */rz` 这条命令，查看系统自带的软件包信息

在输出的信息中，可以看出 rz包的路径，说明 rz包是存在的。

![包存在](Project4_Report.assets/%E5%8C%85%E5%AD%98%E5%9C%A8.PNG)

2. 确认 rz 包存在之后，使用命令 `yum -y install lrzsz `进行包的安装（下图表示安装成功）

   ![安装成功](Project4_Report.assets/%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG)

3. 安装好之后，就可以使用 rz 命令将本地文件上传到 linux 服务器了，输入 rz 命令，找到要上传的文件

   但是

